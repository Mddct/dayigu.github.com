<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>dayigu</title>
    <link href="http://dayigu.github.com/feed/" rel="self" />
    <link href="http://yihui.name/" />
    <lastBuildDate>2012-04-18T01:37:29+08:00</lastBuildDate>
    <webMaster>xie@yihui.name</webMaster>
    
    <item>
      <title>html5 动画实例分析: Blob</title>
      <link href="http://dayigu.github.com/2012/04/html5-animation-example/"/>
      <pubDate>2012-04-17T00:00:00+08:00</pubDate>
      <author>dayigu</author>
      <guid>http://dayigu.github.com/2012/04/html5-animation-example</guid>
      <content:encoded><![CDATA[<p>在 html5 动画的众多&#8221;炫&#8221;的例子中，<a href='http://hakim.se/experiments/html5/blob/03/'>Blob</a> 是尤为出色的一个，其特色在于对物理的模拟: 液滴的运动、分离、合并都相当逼真。下面将对这个例子进行分析，不仅要找到其中对物理规律的模拟方法，也学习一下 javascript 的技巧。</p>

<h1 id='html'>html文件</h1>

<p>首先查看 html 源文件，并把无关紧要的部分删除，就能找到模拟的关键部分:</p>

<pre><code>&lt;body data-twttr-rendered=&quot;true&quot;&gt;
	&lt;div id=&quot;panel&quot;&gt;
     &lt;h2&gt;&lt;a href=&quot;http://hakim.se/experiments/&quot;&gt;Experiments&lt;/a&gt; / Blob  / 03&lt;/h2&gt;
     &lt;p&gt;&lt;b&gt;Double click&lt;/b&gt; on a blob to split it, drag together to merge&lt;br&gt;&lt;b&gt;Shake&lt;/b&gt; the browser window to make them bounce.&lt;br&gt;Use the keyboard &lt;b&gt;&lt;a id=&quot;keyboardUp&quot; href=&quot;http://hakim.se/experiments/html5/blob/03/#&quot;&gt;up&lt;/a&gt; / &lt;a id=&quot;keyboardDown&quot; href=&quot;http://hakim.se/experiments/html5/blob/03/#&quot;&gt;down&lt;/a&gt;&lt;/b&gt; arrows to change blob size and&lt;br&gt;the &lt;b&gt;&lt;a id=&quot;keyboardLeft&quot; href=&quot;http://hakim.se/experiments/html5/blob/03/#&quot;&gt;left&lt;/a&gt; / &lt;a id=&quot;keyboardRight&quot; href=&quot;http://hakim.se/experiments/html5/blob/03/#&quot;&gt;right&lt;/a&gt;&lt;/b&gt; arrows to change between skins.&lt;/p&gt;
&lt;/div&gt;		
&lt;canvas id=&quot;world&quot; width=&quot;1124&quot; height=&quot;693&quot;&gt;&lt;p class=&quot;noCanvas&quot;&gt;You need a &lt;a href=&quot;http://www.google.com/chrome&quot;&gt;modern browser&lt;/a&gt; to view this.&lt;/p&gt;&lt;/canvas&gt;
&lt;script src=&quot;./Blob_files/blob.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;</code></pre>

<p>可见，动画都绘制在 id 为 world 的 canvas 中的，动画则由 blob.min.js 所控制。</p>

<h1 id='js_'>js 文件</h1>

<p>blob.min.js 中主要定义了对象 Blob 和 BlobWorld，前者是液滴对象，后者是液滴的控制。</p>

<h2 id='blob'>Blob</h2>

<p>先看 Blob:</p>

<pre><code>function Blob(){
    this.position={x:0,y:0}; // 位置
    this.velocity={x:0,y:0}; // 速度
    this.radius=85;		     // 半径
    this.nodes=[];           // 节点对象数组，节点只记录边界
    this.rotation={current:0,target:0};  // 旋转
    this.dragNodeIndex=-1;     // 拉伸的node序号
    this.lastSplitTime=0;      // 上次分裂时间
    this.quality=16;           // 质量, 其实是节点数量，即周长
    this.dirtyRegion=new Region // 弄脏的区域，指涂抹过的地方，下一个时刻需要刷新
}</code></pre>

<p>这相当于 Blob 的构造函数。其中关键的量是 nodes，它是边界单元的一维链表。//(注意观察液滴的行为，其周长是不变的，而体积／面积是变化的，这一点不符合物理)</p>

<p>以下是用 prototype 方法定义的成员函数。</p>

<p>生成节点 generateNodes:</p>

<pre><code>Blob.prototype.generateNodes=function(){
	this.nodes=[];
	var b,e;
	for(b=0;b&lt;this.quality;b++){
		e={normal:{x:0,y:0},normalTarget:{x:0,y:0},position:{x:this.position.x,y:this.position.y},ghost:{x:this.position.x,y:this.position.y},angle:0};
	this.nodes.push(e)
	}
	this.updateJoints();
	this.updateNormals()
};</code></pre>

<p>可见 nodes 中存放的是一个个对象，对象中有属性:</p>

<ul>
<li>normal: 节点的位置坐标</li>

<li>normalTarget: 节点的目标位置坐标</li>

<li>position: 位置坐标</li>

<li>ghost: 上一时刻的位置</li>

<li>angle: 角度</li>

<li>joint: 链接，为 Joint 对象</li>
</ul>

<p>初始化时 joint 不设置，在 updateJoints中设。链接记录前后各3个node，共6个。getArrayIndexByOffset 用于寻找相邻的单元序号，根据序号创建 Joint 对象。Joint 对象的属性有 node，strength 和 strain。</p>

<p>然后用 updateNormals 建立节点的法向。</p>

<p>初始化后的液滴是 完美的圆形。</p>

<p>split: 分裂</p>

<p>分裂时将 nodes 中的前一半放到新建立的 Blob 对象中，本身只剩下一半，半径也各变为一半。并各自给一个水平速度，使其分开。</p>

<p>merge: 合并</p>

<p>合并时将两个液滴的速度取平均，作为合并后的速度(如果两个液滴大小不同，则不符合动量守恒)。半径也是二者直接相加。</p>

<h2 id='blobworld'>BlobWorld</h2>

<p>BlobWorld 也是个对象，其成员变量有: g,t,l,j,q,I,u,v,y,f,K,x,w,C。</p>

<ul>
<li>g: 区域尺寸参数</li>

<li>t: canvas 对象</li>

<li>l: canvas 的 2d context 对象</li>

<li>j 用于存放液滴 blob 对象</li>

<li>q</li>

<li>I,J: 窗口相对于屏幕的坐标. 当移动窗口时，根据I，J的变化改变速度</li>

<li>u，v: 速度</li>

<li>y</li>

<li>f</li>

<li>K: 速度参数，其中 y 速度为 1.2, 相当于有一定的重力</li>

<li>x: 记录2个液滴的序号</li>

<li>w</li>

<li>C: 填充颜色、线条颜色等</li>
</ul>

<h3 id='id2'>初始化</h3>

<p>其入口是 init()。</p>

<pre><code>this.init=function(){
if((t=document.getElementById(&quot;world&quot;))&amp;&amp;t.getContext){
    l=t.getContext(&quot;2d&quot;);
    document.addEventListener(&quot;mousemove&quot;,e,false);
    t.addEventListener(&quot;mousedown&quot;,i,false);
    t.addEventListener(&quot;dblclick&quot;,M,false);
    document.addEventListener(&quot;mouseup&quot;,k,false);
    document.addEventListener(&quot;keydown&quot;,N,false);
    t.addEventListener(&quot;touchstart&quot;,s,false);
    t.addEventListener(&quot;touchmove&quot;,z,false);
    t.addEventListener(&quot;touchend&quot;,L,false);
    window.addEventListener(&quot;resize&quot;,H,false);
    document.getElementById(&quot;keyboardUp&quot;).addEventListener(&quot;click&quot;,O,false);
    document.getElementById(&quot;keyboardDown&quot;).addEventListener(&quot;click&quot;,P,false);
    document.getElementById(&quot;keyboardLeft&quot;).addEventListener(&quot;click&quot;,Q,false);
    document.getElementById(&quot;keyboardRight&quot;).addEventListener(&quot;click&quot;,R,false);
    b({x:g.width*0.15,y:g.height*Math.random()*0.2},{x:g.width*0.011,y:0});
    b({x:g.width*0.85,y:g.height*Math.random()*0.2},{x:-g.width*0.011,y:0});
    H();
    setInterval(S,1E3/60)
}
}</code></pre>

<p>t 是 canvas 对象，l 是 2d context。然后把鼠标事件绑定到函数上。</p>

<p>比如双击鼠标 dbclick，调用 M()，M() 再调用 G()，G()中进行分裂。</p>

<p>init() 中首先调用 b() 生成两个 Blob 对象。初始位置在左、右上角，初始速度相对。</p>

<p>然后调用 H()，设定几何尺寸。</p>

<p>最后设置定时函数 setInterval，每1／60 s执行一次 S()。</p>

<h3 id='id3'>运动模拟</h3>

<p>S() 是模拟液滴运动的核心函数。</p>

<p>不知是作者的习惯，或是有意，经常写一些混乱的代码，如:</p>

<pre><code>h=0;
for(n=j.length;h&lt;n;h++){</code></pre>

<p>一般写法:</p>

<pre><code>n=j.length;
for(h=0;h&lt;n;h++){</code></pre>

<p>如果有两个液滴，而且距离上次分裂的时间大于 500s 就合并。</p>

<p>模拟运动时，考虑了液滴质心的运动、鼠标拖拽、自身旋转，以及相邻节点的牵引作用。计算这些作用对坐标的影响时，基本都采用了亚松弛的方法，如:</p>

<pre><code>	c.normal.x+=(c.normalTarget.x-c.normal.x)* 0.05;
	c.normal.y+=(c.normalTarget.y-c.normal.y)*0.05;

	c.position.x+=(p.x-c.position.x)*0.1;
	c.position.y+=(p.y-c.position.y)*0.1;</code></pre>

<h3 id='id4'>其他函数</h3>

<p>D(f,h): 找出距离点h最近的液滴f中的节点node</p>

<h1 id='end'>end</h1>

<p>通过这个例子，对 javascript 的特点有了点了解。关于 javascript 在面向对象方面的编程，可参考<a href='http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html'>阮一峰的网络日志</a>, 其讲解清晰、透彻。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>HTML5 动画</title>
      <link href="http://dayigu.github.com/2012/04/html5-animation/"/>
      <pubDate>2012-04-16T00:00:00+08:00</pubDate>
      <author>dayigu</author>
      <guid>http://dayigu.github.com/2012/04/html5-animation</guid>
      <content:encoded><![CDATA[<p>十几年前刚接触网络的时候，网页还非常的简单、朴素，让网页&#8221;花哨&#8221;一点的方法就是加上点动画。当时加动画的方法主要是两种: java applet 和 gif 图片。慢慢地，java applet 退出去了，现在多数浏览器默认都不载入了。这期间出现了 flash，但主要用作放广告和播放视频，而且也快要退出了。还出现过 vml，但需要另外安装浏览器插件，没有流行起来。以至于 gif 仍然简陋，却依然坚守。不过，这种状况已经在改变了。HTML5 和 svg 的日益流行和被主流浏览器的支持， 让在网页上加动画更加方便了。</p>

<p>目前，最新的主流浏览器都已默认支持 html5 和 svg的主要特性，包括动画。svg 的也能够做出很炫的动画效果，<a href='http://srufaculty.sru.edu/david.dailey/svg/'>这儿</a>有丰富的例子。svg 的优点是其矢量性，不仅能用于网络，也能作为独立的图片。但相比起来，html5的动画则更加简单和直接，下面将给出一个简单的例子。</p>

<p>html5 绘制的图形都是放在 html element <code>&lt;canvas&gt;&lt;/canvas&gt;</code> 中的。canvas 就相当于一块画布，是页面上的一块方形区域，所有的图形、动画都在这块画布上展现。因此首选要在 html 文件的body中加入 canvas，指定其 id，还可以指定大小。</p>

<pre><code>  &lt;canvas id=&quot;canvas&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;</code></pre>

<p>画图和动画的工作就交给 javascript 了。在 javascript 中，首先要根据 html 中的 canvas 的id创建 canvas 对象，再得到绘图的 上下文(context)对象。</p>

<pre><code>  canvas = document.getElementById(&#39;canvas&#39;);
  g = canvas.getContext(&quot;2d&quot;);</code></pre>

<p>其中 g 就是绘制二维图形的上下文对象，可想而知还应该有 3d 对象，不过目前还未得到广泛的支持。2d 对象在大多数最新的浏览器中都得到支持了。g 就类似于传统桌面程序中的图形对象指针。g 提供了基本的形状的绘制方法，如绘一个圆:</p>

<pre><code>g.beginPath();					
g.arc(x,y, radius, 0, TWO_PI, true);
g.closePath();
g.stroke();							</code></pre>

<p>动画就是让这些图形按照时间间隔重绘，先用 clearRect 把所有区域清空，再画一次。按照一定的时间间隔调用绘图函数，要用到 setInterval 方法:</p>

<pre><code>  setInterval(draw_scene, 40);</code></pre>

<p>即每隔 40ms调用一次 draw_scene 方法。</p>

<p>下面给出简单的例子，就是 <a href='http://dayigu.github.com/2012/04/planet-in-conjunction-with-star/'>行星与恒星的合周期</a> 中的行星运动的例子，<a href='http://dayigu.github.com/html/planet_star_conjunction.html'>演示</a>。</p>

<p>主要的绘图函数放在了一个独立的 js 文件中了，简单的封装了一下。</p>

<h2 id='id1'>参考资料:</h2>

<ul>
<li><a href='https://developer.mozilla.org/cn/Canvas_tutorial'>Canvas教程</a></li>

<li><a href='http://www.funnyhao.com/a-js-animation-framework-based-on-html5-canvas/'>一个JS动画框架</a></li>
</ul>]]></content:encoded>
    </item>
    
    <item>
      <title>行星的相位</title>
      <link href="http://dayigu.github.com/2012/04/planet-phase/"/>
      <pubDate>2012-04-13T00:00:00+08:00</pubDate>
      <author>dayigu</author>
      <guid>http://dayigu.github.com/2012/04/planet-phase</guid>
      <content:encoded><![CDATA[<p>月有阴晴圆缺是说的从地球上看月球有相位的变化。那么行星有相位变化吗? 有，只不过从地球上看行星只能看到光点，无法辨别它的圆缺，它的相位对其亮度是有影响的。</p>

<p>相(phase)一般定义为可见区域中的日照部分占总日照区域(对球形天体日照区域为一半)的比例，如果能看见全部的光照区域，相为1, 如果看见的区域全部为黑夜，则相为0。根据这个定义，以火星为例，相与日－火连线和地－火连线的夹角有关，见下图。</p>

<p><img alt='相的计算' src='/images/phase_define.png' /></p>

<p>假设行星轨道为理想圆，所有行星轨道都在同一个平面上，则从地球上看行星的相变化的计算见下图:</p>

<p><img alt='行星的相计算' src='/images/planet_phase.png' /></p>

<p>可以看出，当地球外侧行星与地球相冲时相位最大，相合时也最大，但此时无法直接观测。地球内侧行星与地球相冲时相位最小，相合时相位最大。</p>

<p>google search graph 没有提供arctan2/atan2 函数，因此不能用它来画金星相位变化曲线。下面是用 Python+matplotlib 画的金星的相位变化曲线:</p>

<pre><code>import numpy as np
t=np.linspace(0,5,200)
plot(t,(pi-abs(np.arctan2(np.sin(2*pi*t*(1-1/0.62)),(0.72-np.cos(2*pi*t*(1-1/0.62))))))/pi)
axis([0, 3.5, 0, 1])
xlabel(&#39;year&#39;)
ylabel(&#39;phase&#39;)
title(&#39;venus&#39;)</code></pre>

<p><img alt='金星的相位变化' src='/images/venus_phase.png' /></p>

<p>对于地球外侧行星，其相位角beta不会大于pi/2, 因此可以用google search graph 来绘制相位变化曲线。</p>

<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=(pi-abs(atan(sin(2pi*x(1-1%2F1.88))%2F(1.52-cos(2pi*x(1-1%2F1.88))))))%2Fpi'>火星</a>的相位变化见下图。最大相位为1，发生在冲、合时。其中较尖锐的锋为冲，较钝的锋为合。最小相约为0.77。其波动周期就取决于地球与火星的合会周期。</p>

<p><img alt='火星的相位变化' src='/images/mars_phase.png' /></p>

<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=(pi-abs(atan(sin(2pi*x(1-1%2F11.87))%2F(5.2-cos(2pi*x(1-1%2F11.87))))))%2Fpi'>木星</a>的相变化为:</p>

<p><img alt='木星的相位变化' src='/images/jupiter_phase.png' /></p>

<p>可见其相位都很大，最小值为0.94. 变化周期约为1年。</p>

<p>对于更远的行星，<a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=(pi-abs(atan(sin(2pi*x(1-1%2F29.53))%2F(9.55-cos(2pi*x(1-1%2F29.53))))))%2Fpi'>土星</a>, <a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=(pi-abs(atan(sin(2pi*x(1-1%2F84.55))%2F(19.26-cos(2pi*x(1-1%2F84.55))))))%2Fpi'>天王星</a>, <a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=(pi-abs(atan(sin(2pi*x(1-1%2F166.24))%2F(30.23-cos(2pi*x(1-1%2F166.24))))))%2Fpi'>海王星</a>，其相位变化范围更小。</p>]]></content:encoded>
    </item>
    
    <item>
      <title>行星与恒星的合周期</title>
      <link href="http://dayigu.github.com/2012/04/planet-in-conjunction-with-star/"/>
      <pubDate>2012-04-13T00:00:00+08:00</pubDate>
      <author>dayigu</author>
      <guid>http://dayigu.github.com/2012/04/planet-in-conjunction-with-star</guid>
      <content:encoded><![CDATA[<p>行星与恒星相合是指从地球看过去，行星与该恒星在同一个方位，比如金星与昴星团相合。当然相合的条件首先是恒星位于太阳系行星运行的轨道平面上。那么某行星与某恒星相合的周期是多少呢?</p>

<p>假设行星的轨道都为圆，且与地球轨道在同一平面上. 行星与恒星相合的条件见下图(O为太阳，E是地球，M是行星，以火星为例，S是恒星的方向):(<a href='http://dayigu.github.com/html/planet_star_conjunction.html'>动画</a>)</p>

<p><img alt='行星与恒星相合的条件' src='/images/planet_star_conjunction.png' /></p>

<p>假设在 t=0 时相合，经过 t 的时间再次相合，则 e-&gt;v 必须达到与 t＝0 相同的方向，即E和M的y坐标相同，且E在M的左侧. 因此得到相合的条件:</p>

<p><img alt='相合方程' src='/images/latex/eq_7378894517581845269_2.png' /> 且 <img alt='相合条件' src='/images/latex/eq_2329005520818939421_2.png' /></p>

<p>如果是地球内侧的行星，如金星，则后面的不等式要反号。</p>

<p>该方程不好求解，因此把这两个等式和不等式的两项差值随时间的变化画出来(用 google 搜索直接可以画出曲线)。</p>

<p>如以<a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2pi*x)-0.72*sin(2pi*x%2F0.62)%2C+cos(2pi*x)-0.72*cos(2pi*x%2F0.62)'>金星</a>为例，a=0.72, 公转周期为0.62年。</p>

<p><img alt='金星与恒星的会合' src='/images/venus_conjunction.png' /></p>

<p>当蓝色曲线经过x轴，且红色曲线在x轴上面时发生一次相合。因此平均每年内发生1次相合。但也可能某年内相合2次，接下来的1年内没有。</p>

<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-1.52*sin(2*pi*x%2F1.88)%2C+cos(2pi*x)-1.52*cos(2pi*x%2F1.88)'>火星</a>(a=1.52, 公转周期1.88年)的曲线如下，蓝色曲线经过x轴，且红色曲线在x轴下面时相合，平均每2年1次(周期稍大于1／2, 如前26年发生14次)。</p>

<p><img alt='火星与恒星的会合' src='/images/mars_conjunction.png' /> 木星会合周期就更长了，基本上在木星的公转一周中，只有1次机会与其他恒星相合。但是由于木星的公转较慢，在发生相合的连续一两年内都处于相合的位置。</p>

<p><img alt='木星与恒星的会合' src='/images/jupiter_conjunction.png' /> 更外层行星与恒星的会合规律与木星相同，都是在公转一周中发生1次, 但每次会合的持续时间会比较长。</p>

<p>以上的曲线都能用 google search graph 的功能直接画出:</p>

<ul>
<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2pi*x)-0.72*sin(2pi*x%2F0.62)%2C+cos(2pi*x)-0.72*cos(2pi*x%2F0.62)'>金星</a></p>
</li>

<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-1.52*sin(2*pi*x%2F1.88)%2C+cos(2pi*x)-1.52*cos(2pi*x%2F1.88)'>火星</a></p>
</li>

<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-5.20*sin(2*pi*x%2F11.87)%2C+cos(2pi*x)-5.20*cos(2pi*x%2F11.87)'>木星</a></p>
</li>

<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-9.55*sin(2*pi*x%2F29.53)%2C+cos(2pi*x)-9.55*cos(2pi*x%2F29.53)'>土星</a></p>
</li>

<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-19.26*sin(2*pi*x%2F84.55)%2C+cos(2pi*x)-19.26*cos(2pi*x%2F84.55)'>天王星</a></p>
</li>

<li>
<p><a href='http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=sin(2*pi*x)-30.23*sin(2*pi*x%2F166.24)%2C+cos(2pi*x)-30.23*cos(2pi*x%2F166.24)'>海王星</a></p>
</li>
</ul>]]></content:encoded>
    </item>
    
  </channel>
</rss>
